= Лабораторная работа №5
:toc: macro
:toc-title: Оглавление

include::titulnik.adoc[]

toc::[]

== Принцип работы системы

Система представляет собой контроллер для управления группой светодиодов с поддержкой нескольких режимов работы. Архитектура построена на основе объектно-ориентированного подхода с четким разделением ответственности между компонентами.

=== Основной рабочий цикл

[source,cpp]
----
for(;;)
  {   
    if (userButton.WasPressed())
    {
      modeController.SwitchMode(); 
    }
    delay(500000);
    modeController.RunCurrentMode(); 
  }
----

Реализованы три режима работы:

* **RunningLightMode** — последовательное переключение светодиодов (режим "бегущий огонь")
* **FadeGlowMode** — синхронное управление всеми светодиодами  
* **ChessMode** — попеременное включение светодиодов в шахматном порядке

Каждый режим инкапсулирует собственную логику управления, взаимодействуя со светодиодами исключительно через абстрактные интерфейсы.

== Обоснование выбора интерфейсов

=== Минималистичный дизайн IButton

Интерфейс IButton был спроектирован с фокусом на минимально необходимую функциональность:

[source,cpp]
----
class IButton {
public:
    virtual bool WasPressed() const = 0;
};
----

 Такой подход обеспечивает:
* Простоту реализации для различных аппаратных платформ
* Снижение связанности между компонентами из-за чего можно делать Unit-тесты

=== Разделение интерфейсов управления светодиодами

Изначально рассматривался унифицированный интерфейс, объединяющий все возможные операции со светодиодами. Однако анализ сценариев использования выявил необходимость разделения:

[source,cpp]
----
class ILedToggable {
public:
    virtual void Toggle() const = 0;
};

class ILedOnOff {
public:
    virtual void On() const = 0;
    virtual void Off() const = 0;
};
----

**Техническое обоснование разделения:**

1. **RunningLightMode** требует только операции переключения состояния
2. **ChessMode** нуждается в явном управлении состоянием каждого светодиода
3. Соблюдение принципа разделения интерфейсов (Interface Segregation Principle)

Такой дизайн позволяет классам реализовывать только необходимую функциональность.

== Процесс определения абстракций

Проектирование архитектуры системы выполнялось итеративно, с постепенным выделением абстракций из первоначальной монолитной реализации.

=== Первоначальный подход

Начальная реализация представляла собой единый модуль, содержащий:
* Логику управления аппаратными светодиодами
* Обработку пользовательского ввода
* Реализацию всех режимов работы

Данный подход быстро продемонстрировал недостатки при попытке добавления новых функциональных возможностей.

=== Выявление ключевых абстракций

В процессе рефакторинга были идентифицированы и выделены следующие абстракции:

1. **Управление светодиодами** 
2. **Обработка пользовательского ввода** 
3. **Реализация режимов работы** 

=== Создание иерархии CommonMode

Анализ повторяющегося кода в различных режимах привел к созданию базового класса CommonMode, содержащего:

* Ссылки на управляемые светодиоды
* Текущий индекс активного светодиода
* Стандартную реализацию метода Init()

Данное решение устранило дублирование кода и упростило создание новых режимов.


=== Архитектурное преобразование

В процессе рефакторинга было осознано, что различные режимы работы представляют собой альтернативные алгоритмы достижения общей цели — управления светодиодами. Это понимание привело к созданию унифицированного интерфейса:

[source,cpp]
----
class IMode {
public:
    virtual void Init() = 0;
    virtual void Execute() = 0;
};
----

Контроллер режимов был переработан для работы с абстракциями:

[source,cpp]
----
void ModeController::RunCurrentMode() {
    mModes[mCurrentMode]->Execute();
}
----

=== Преимущества полученной архитектуры

Реализация паттерна Стратегия обеспечила следующие преимущества:

1. **Расширяемость** — добавление нового режима требует только создания нового класса, реализующего интерфейс IMode
2. **Тестируемость** — каждый режим может тестироваться изолированно
3. **Сопровождаемость** — логика каждого режима инкапсулирована в отдельном классе
4. **Чистота архитектуры** — контроллер не зависит от конкретных реализаций режимов

=== Диаграмма классов системы

На представленной UML диаграмме классов отображена архитектура системы управления светодиодами. Диаграмма демонстрирует следующие ключевые аспекты:

* **Интерфейсы и их реализации**: Показаны основные интерфейсы IButton, IMode, ILedToggable и ILedOnOff с их конкретными реализациями
* **Наследование и композиция**: Отображена иерархия классов, где CommonMode служит базовым классом для всех режимов работы, а конкретные режимы наследуют его функциональность
* **Зависимости между компонентами**: ModeController использует интерфейс IMode для работы с различными режимами, обеспечивая слабую связанность
* **Разделение интерфейсов**: Классы Led и OptimizedLed реализуют оба интерфейса управления светодиодами, что позволяет использовать их в различных контекстах

Диаграмма наглядно иллюстрирует применение принципов SOLID, в частности принципа разделения интерфейсов и открытости/закрытости.

image::UML.jpg[]

== Заключение

Разработанная архитектура демонстрирует эффективное применение объектно-ориентированных принципов проектирования в области встраиваемых систем. Ключевыми достижениями являются:

* Четкое разделение ответственности между компонентами
* Минималистичный дизайн интерфейсов, ориентированный на конкретные потребности системы
* Гибкая архитектура, поддерживающая простое расширение функциональности
* Естественное применение паттернов проектирования через практический анализ проблем

В приложении будут продеставлен полный код программы и код по каждому интерфейсу, а также их расположение в директории проекта.

== Приложение



=== Полный код программы

[source,cpp]
----
include::Laba5\main.cpp[]
----

=== Расположение файлов

image::laba5.png[]

=== IButton.h

[source,cpp]
----
include::Laba5\\Application\\Button\\Contrats\\IButton.h[]
----

=== UserButton.cpp

[source,cpp]
----
include::Laba5\\Application\\Button\\UserButton.cpp[]
----

=== UserButton.h

[source,cpp]
----
include::Laba5\\Application\\Button\\UserButton.h[]
----

=== IController.h

[source,cpp]
----
include::Laba5\Application\Led\Contracts\ILedOnOff.h[]
----

=== ModeController.cpp

[source,cpp]
----
include::Laba5\\Application\\LcdController\\ModeController.cpp[]
----

=== ModeController.h

[source,cpp]
----
include::Laba5\\Application\\LcdController\\ModeController.h[]
----

=== ILedOnOff.h

[source,cpp]
----
include::Laba5\Application\Led\Contracts\ILedOnOff.h[]
----

=== ILedToggable.h

[source,cpp]
----
include::Laba5\Application\Led\Contracts\ILedToggable.h[]
----

=== Led.cpp

[source,cpp]
----
include::Laba5\\Application\\Led\\Led.cpp[]
----

=== Led.h

[source,cpp]
----
include::Laba5\\Application\\Led\\Led.h[]
----

=== OptimizedLed.h

[source,cpp]
----
include::Laba5\\Application\\Led\\OptimizedLed.h[]
----

=== ChessMode.cpp

[source,cpp]
----
include::Laba5\\Application\\Mode\\ChessMode.cpp[]
----

=== ChessMode.h

[source,cpp]
----
include::Laba5\\Application\\Mode\\ChessMode.h[]
----

=== CommonMode.cpp

[source,cpp]
----
include::Laba5\\Application\\Mode\\CommonMode.cpp[]
----

=== CommonMode.h

[source,cpp]
----
include::Laba5\\Application\\Mode\\CommonMode.h[]
----

=== FadeGlowMode.cpp

[source,cpp]
----
include::Laba5\\Application\\Mode\\FadeGlowMode.cpp[]
----

=== FadeGlowMode.h

[source,cpp]
----
include::Laba5\\Application\\Mode\\FadeGlowMode.h[]
----

=== RunningLightMode.cpp

[source,cpp]
----
include::Laba5\\Application\\Mode\\RunningLightMode.cpp[]
----

=== RunningLightMode.h

[source,cpp]
----
include::Laba5\\Application\\Mode\\RunningLightMode.h[]
----