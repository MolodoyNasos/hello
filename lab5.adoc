= Лабораторная работа №5
:toc: macro
:toc-title: Оглавление

include::titulnik.adoc[]

toc::[]

== Введение
Данная лабораторная работа посвящена разработке системы управления светодиодами с поддержкой нескольких режимов работы. Основной целью проекта является демонстрация применения принципов объектно-ориентированного программирования и паттернов проектирования в контексте встраиваемых систем.
Система представляет собой контроллер для управления группой светодиодов с поддержкой нескольких режимов работы. Архитектура построена на основе объектно-ориентированного подхода с четким разделением ответственности между компонентами.

=== Основной рабочий цикл

[source,cpp]
----
for(;;)
  {   
    if (userButton.WasPressed())
    {
      modeController.SwitchMode(); 
    }
    delay(500000);
    modeController.RunCurrentMode(); 
  }
----

Реализованы три режима работы:

* **RunningLightMode** — последовательное переключение светодиодов (режим "бегущий огонь")
* **FadeGlowMode** — синхронное управление всеми светодиодами  
* **ChessMode** — попеременное включение светодиодов в шахматном порядке

Каждый режим инкапсулирует собственную логику управления, взаимодействуя со светодиодами исключительно через абстрактные интерфейсы.

== Обоснование выбора интерфейсов

=== Минималистичный дизайн IButton

Интерфейс IButton был спроектирован с фокусом на минимально необходимую функциональность:

[source,cpp]
----
class IButton {
public:
    virtual bool WasPressed() const = 0;
};
----

 Такой подход обеспечивает:
* Простоту реализации для различных аппаратных платформ
* Снижение связанности между компонентами из-за чего можно делать Unit-тесты

=== Разделение интерфейсов управления светодиодами

Изначально рассматривался унифицированный интерфейс, объединяющий все возможные операции со светодиодами. Однако анализ сценариев использования выявил необходимость разделения:

[source,cpp]
----
class ILedToggable {
public:
    virtual void Toggle() const = 0;
};

class ILedOnOff {
public:
    virtual void On() const = 0;
    virtual void Off() const = 0;
};
----

**Техническое обоснование разделения:**

1. **RunningLightMode** требует только операции переключения состояния
2. **ChessMode** нуждается в явном управлении состоянием каждого светодиода
3. Соблюдение принципа разделения интерфейсов (Interface Segregation Principle)

Такой дизайн позволяет классам реализовывать только необходимую функциональность.

== Процесс определения абстракций

Проектирование архитектуры системы выполнялось итеративно, с постепенным выделением абстракций из первоначальной монолитной реализации.

=== Первоначальный подход

Начальная реализация представляла собой единый модуль, содержащий:
* Логику управления аппаратными светодиодами
* Обработку пользовательского ввода
* Реализацию всех режимов работы

Данный подход быстро продемонстрировал недостатки при попытке добавления новых функциональных возможностей.

=== Выявление ключевых абстракций

В процессе рефакторинга были идентифицированы и выделены следующие абстракции:

1. **Управление светодиодами** 
2. **Обработка пользовательского ввода** 
3. **Реализация режимов работы** 

=== Создание иерархии CommonMode

Анализ повторяющегося кода в различных режимах привел к созданию базового класса CommonMode, содержащего:

- Ссылки на управляемые светодиоды
- Текущий индекс активного светодиода
- Стандартную реализацию метода Init()

Данное решение устранило дублирование кода и упростило создание новых режимов.


=== Архитектурное преобразование

В процессе рефакторинга было осознано, что различные режимы работы представляют собой альтернативные алгоритмы достижения общей цели — управления светодиодами. Это понимание привело к созданию унифицированного интерфейса:

[source,cpp]
----
class IMode {
public:
    virtual void Init() = 0;
    virtual void Execute() = 0;
};
----

Контроллер режимов был переработан для работы с абстракциями:

[source,cpp]
----
void ModeController::RunCurrentMode() {
    mModes[mCurrentMode]->Execute();
}
----

=== Преимущества полученной архитектуры

1. Расширяемость — добавление нового режима требует только создания нового класса, реализующего интерфейс IMode
2. Тестируемость — каждый режим может тестироваться изолированно
3. Сопровождаемость — логика каждого режима инкапсулирована в отдельном классе
4. Чистота архитектуры — контроллер не зависит от конкретных реализаций режимов

=== Диаграмма классов системы

На представленной UML диаграмме классов отображена архитектура системы управления светодиодами. 
Диаграмма наглядно иллюстрирует применение принципов SOLID.

image::UML.jpg[]

== Выводы

Разработанная система управления светодиодами демонстрирует эффективное применение объектно-ориентированных принципов проектирования в контексте встраиваемых систем.
Полученная архитектура обеспечивает простоту добавления новых режимов работы и может быть адаптирована для управления различными типами исполнительных устройств.

== Приложение:

[source,cpp]
----
include::Laba5\main.cpp[]
----

=== Расположение файлов

image::laba5.png[]

=== IButton.h

[source,cpp]
----
include::Laba5\\Application\\Button\\Contrats\\IButton.h[]
----

=== UserButton.cpp

[source,cpp]
----
include::Laba5\\Application\\Button\\UserButton.cpp[]
----

=== UserButton.h

[source,cpp]
----
include::Laba5\\Application\\Button\\UserButton.h[]
----

=== IController.h

[source,cpp]
----
include::Laba5\Application\Led\Contracts\ILedOnOff.h[]
----

=== ModeController.cpp

[source,cpp]
----
include::Laba5\\Application\\LcdController\\ModeController.cpp[]
----

=== ModeController.h

[source,cpp]
----
include::Laba5\\Application\\LcdController\\ModeController.h[]
----

=== ILedOnOff.h

[source,cpp]
----
include::Laba5\Application\Led\Contracts\ILedOnOff.h[]
----

=== ILedToggable.h

[source,cpp]
----
include::Laba5\Application\Led\Contracts\ILedToggable.h[]
----

=== Led.cpp

[source,cpp]
----
include::Laba5\\Application\\Led\\Led.cpp[]
----

=== Led.h

[source,cpp]
----
include::Laba5\\Application\\Led\\Led.h[]
----

=== OptimizedLed.h

[source,cpp]
----
include::Laba5\\Application\\Led\\OptimizedLed.h[]
----

=== ChessMode.cpp

[source,cpp]
----
include::Laba5\\Application\\Mode\\ChessMode.cpp[]
----

=== ChessMode.h

[source,cpp]
----
include::Laba5\\Application\\Mode\\ChessMode.h[]
----

=== CommonMode.cpp

[source,cpp]
----
include::Laba5\\Application\\Mode\\CommonMode.cpp[]
----

=== CommonMode.h

[source,cpp]
----
include::Laba5\\Application\\Mode\\CommonMode.h[]
----

=== FadeGlowMode.cpp

[source,cpp]
----
include::Laba5\\Application\\Mode\\FadeGlowMode.cpp[]
----

=== FadeGlowMode.h

[source,cpp]
----
include::Laba5\\Application\\Mode\\FadeGlowMode.h[]
----

=== RunningLightMode.cpp

[source,cpp]
----
include::Laba5\\Application\\Mode\\RunningLightMode.cpp[]
----

=== RunningLightMode.h

[source,cpp]
----
include::Laba5\\Application\\Mode\\RunningLightMode.h[]
----
